

# ベース、アプリ、メインモジュール

この章では、**Base**, **App**, **Main**モジュールの名前空間を紹介します。これらの関数は、"import FreeCAD" によって python でアクセスできます。[FreeCAD module](https://www.freecadweb.org/api/FreeCAD.html) を参照してください。

この章では、App 名前空間のプロパティフレームワークと `DocumentObject` に焦点を当てます。Base 名前空間のクラスは頻繁に使用されるものではないが、型システムの理解は有用であろう。最後に、FreeCAD の起動プロセスは **Main** ソースコードフォルダで追跡される。


## Base フォルダ内のヘッダーファイルのリスト

[このセクションは python スクリプトによって生成されます。


注意: いくつかのクラスは C++11/17 標準ライブラリや boost にあります。

+ スワップ : std::swap
+ ハンドル : 共有ポインタ
+ FileInfo : ファイル情報：ファイルシステム C++17
+ ユニットと品質: Boostにはユニットライブラリがある。
+ TimeInfo：QDataTime, 64bit タイムスタンプを取得するための C++11

### よく含まれるヘッダーファイル

```cpp
#include <Base/Console.h> // PrintMessage(), ロギング用シングルトン。
#include <Base/Tools.h> // 文字列エンコーディング変換 utf <-> QString
#include <Base/Interpreter.h> // python インタプリタ
#include <Base/Exception.h> // すべての例外は Base::Exception から継承されるべきである。
```


### 文字列のエンコーディング utf8 と wchar_t への変換 QString

FreeCAD の文字列エンコーディングは Qt の wide char とは異なり、[src/Base/Tools.h] のヘルパー関数を使用します。

src/Base/Tools.h] のヘルパー関数 `fromStdString(const std::string & s)` と `toStdString(const QString& s)` を使用します。

```cpp
struct BaseExport Tools
{
    static std::string getUniqueName(const std::string&, const std::vector<std::string>&,int d=0)；
    static std::string addNumber(const std::string&, unsigned int, int d=0)；
    static std::string getIdentifier(const std::string&)；
    static std::wstring widen(const std::string& str)；
    static std::string narrow(const std::wstring& str)；
    static std::string escapedUnicodeFromUtf8(const char *s)；
    /**
     * QString を UTF-8 エンコードされた std::string に変換します。
     * param s 変換する文字列。
     * return UTF-8にエンコードされたstd::string。
     */
    static inline std::string toStdString(const QString& s) { QByteArray tmp = s.toUtf8(); return std::string(tmp.constData(), tmp.size()); }.

    /**
     * UTF-8 でエンコードされた std::string を QString に変換します。
     * UTF-8 でエンコードされた std::string を QString に変換します。
     * return QStringとして表現された文字列。
     */
    static inline QString fromStdString(const std::string & s) { return QString::fromUtf8(s.c_str(), s.size()); }.

}

```

**************************************************

## Type, BaseClass, PyObjectBase

c++ フレームワークにとって重要なのは、ルートとなる基底クラスを持つことです。これにより、参照カウント、継承ツリー、実行時の型情報のような重要な機能が実装されます。Qtの[*QObject*]()、GTKのGObject、VTKの[vtkObjectBase](https://vtk.org/doc/nightly/html/classvtkObjectBase.html)が最良の例です。FreeCADの型システムは参照カウント機能を提供しませんが、継承関係、名前によるクラスインスタンスの作成、Pythonとの接続を提供します。   これらの機能は、Java や C# のようなリフレクションをサポートする言語で利用可能です。

FreeCADでは、型システムは2つの主要なクラス`BaseClass`と`Type`によって実装されています。  これらは独立したリポジトリ<https://github.com/qingfengxia/cppBase>に抽出されており、他のプロジェクトで再利用することができます。

### 型システムの使用法

1. ヘッダファイル 各クラスのヘッダファイル(ヘッダのみのクラスも含む)では、 `TYPESYSTEM_HEADER();` をそのクラスの最初の行に記述します。

```cpp
class CClass : public Base::BaseClass
{
    typesystem_header()；

public：
    int d = 0；
};
```

1. ソース・ファイル クラス・スコープ内ではなく、そのクラスのソース・ファイルの一番最初にある。または、ヘッダーのみのクラスの他のcppファイル。`TYPESYSTEM_SOURCE(CClass,Base::BaseClass);`ヘッダーのみの静的メンバデータ宣言はサポートされていません。
2.メインソースファイル この型システムを使用するには、`main()`またはモジュール初期化関数（`main()`内で呼び出される。）

```c++
int main()
{
    using namespace Base;

    Type::init(); // タイプシステムを開始する。
    // その後、BaseClassを含む各クラスを初期化します。

    BaseClass::init(); // このルート・クラスは初期化する必要があります。

    // ユーザクラスの init、モジュール init() でラップできる
    CClass::init()；

    CClass* cp；
    auto tmp = Base::Type::createInstanceByName("CClass")；
    Base::BaseClass* base = static_cast<Base::BaseClass*>(tmp)；
    if (base)
    {
        if (!base->getTypeId().isDerivedFrom(Base::BaseClass::getClassTypeId()))
        {
            base を削除します；
            std::cout << "'" << sType << "' は Base::BaseClass の型ではありません"；
        }
        cp = static_cast<CClass*>(base)；
    }
    std::cout << cp->getClassTypeId().getName() << std::endl；

    Type::destruct()；
    return 0；
}
```

サンプル・ソースファイル全体は[TypeTest source](https://github.com/qingfengxia/cppBase/blob/master/TypeTest.cpp)を参照のこと。

### 型システムの実装

Base:Unit`クラスと同様に、型情報は構造体*TypeData*に保存される。

[src/Base/Type.h] を参照してください。

```cpp
struct Base::TypeData
{
  TypeData(const char *theName、
           const Type type = Type::badType()、
           const Type theParent = Type::badType()、
           Type::instantiationMethod method = 0
          ):name(theName),parent(theParent),type(type),instMethod(method) { }.

  std::string name；
  親の型
  型；
  Type::instantiationMethod instMethod；
};

class
{
  //...
  static void *createInstanceByName(const char* TypeName, bool bLoadModule=false)；

  static int getAllDerivedFrom(const Type type, std::vector<Type>& List)；

  static int getNumTypes(void)；

  static const Type createType(const Type parent, const char *name,instantiationMethod method = 0)；
private：
  unsigned int index；
  static std::map<std::string,unsigned int> typemap；
  static std::vector<TypeData*> typedata；

  static std::set<std::string> loadModuleSet；
}
```

### [src/Base/BaseClass.h] を参照してください。

このヘッダーは、派生クラスが型システムをサポートするためのルートクラスを定義するだけでなく、QTのQObjectマクロと同様に、ボイラープレートコードを生成するためのマクロ関数も定義しています。

このBaseClassは対応するPyObjectのポインタを保持します。  
`virtual PyObject *getPyObject(void);`

```cpp
#ifndef BASE_BASECLASS_H
#define BASE_BASECLASS_H

#include "Type.h"

// Pythonのもの
typedef struct _object PyObject；


/// Base::BaseClass をサブクラス化するための定義
#define TYPESYSTEM_HEADER()  \
public：\
  static Base::Type getClassTypeId(void);  \
  仮想Base::Type getTypeId(void) const; ￤スタティックvoid init(void)
  static void init(void); \
  static void *create(void);⇦.
private：\
  static Base::Type classTypeId


/// Base::BaseClassのサブクラスを実装するために定義します。
#クラスTypeId /// Base::BaseClassのサブクラスを実装するために定義します。
Base::Type _class_::getClassTypeId(void) { return _class_::classTypeId; }.\
Base::タイプ _class_::getTypeId(void) const { return _class_::classTypeId; } ⑬クラスタイプを取得します。\
Base::Type _class_::classTypeId = Base::Type::badType();  \
void * _class_::create(void){
   return new _class_ ();ʕ-̫͡-ʔ
}

/// Base::BaseClassのサブクラスを実装するための定義
#を定義します。
Base::Type _class_::getClassTypeId(void) { return _class_::classTypeId; } /// Base::BaseClass のサブクラスを定義します。\
\
Base::Type _class_::classTypeId = Base::Type::badType();  \
void * _class_::create(void){return 0;}.


/// Base::BaseClassのサブクラスを実装するための定義
#TYPESYSTEM_SOURCE(_class_, _parentclass_) を定義します。
TYPESYSTEM_SOURCE_P(_class_);。
void _class_::init(void){}.
  
}

/// Base::BaseClassのサブクラスを実装するための定義
#を実装するために定義します。
TYPESYSTEM_SOURCE_ABSTRACT_P(_class_);。
void _class_::init(void){}.
  を作成します。
}

namespace Base
{
/// BaseClassクラスと型システムのルート
class BaseExport BaseClass
{
public：
  static Type getClassTypeId(void)；
  virtual Type getTypeId(void) const；
  bool isDerivedFrom(const Type type) const {return getTypeId().isDerivedFrom(type);}.

  static void init(void)；

  virtual void setPyObject(void)；
  virtual void setPyObject(PyObject *)；

  static void *create(void){return 0;}.
private：
  static Type classTypeId；
protected：
  static void initSubclass(Base::Type &toInit,const char* ClassName, const char *ParentName, Type::instantiationMethod method=0)；

public：
  /// 構築
  BaseClass()；
  /// 破壊
  virtual ~BaseClass()；

};



}// 名前空間 Base


#endif // BASE_BASECLASS_H

///////////////////////////////////////////////////////////////////////////////
#include "PreCompiled.h"

#ifndef _PreComp_
#include <assert.h>
#endif

/// ここに FreeCAD のインクルードを Base、App、Gui......の順に並べます。
#include "BaseClass.h"
#include "PyObjectBase.h"

using namespace Base；

BaseClass::classTypeId = Base::Type::badType()；


//**************************************************************************
// その他の実装のためのセパレータ

void BaseClass::init(void)
{
    assert(BaseClass::classTypeId == Type::badType() && "init()を2回するな！")；
    /* スーパークラスがサブクラスより先に初期化されることを確認する。*/
    /*assert(strcmp(#_parentclass_), "inherited"));*/
    /*Type parentType(Type::fromName(#_parentclass_));*/.
    /*assert(parentType != Type::badType() && "parentclassのinit()を忘れています！");*/.

    /* 型システムのエントリを設定します。*/
    ベースクラス::classTypeId =
        Type::createType(Type::badType()、
                         "Base::BaseClass"、
                         BaseClass::create)；
}

型 BaseClass::getClassTypeId(void)
{
    BaseClass::classTypeId を返します；
}

型 BaseClass::getTypeId(void) const
{
    BaseClass::classTypeId を返します；
}


void BaseClass::initSubclass(Base::Type &toInit,const char* ClassName, const char *ParentName、
                             Type::instantiationMethod method)
{
    // 二度 init しない！
    assert(toInit == Base::Type::badType())；
    // 親クラスを取得する
    Base::Type parentType(Base::Type::fromName(ParentName))；
    // 親クラスの初期化を忘れる
    assert(parentType != Base::Type::badType() )；

    // 新しい型を作成する
    toInit = Base::Type::createType(parentType, ClassName, method)；
}

/**
 * このメソッドは C++ オブジェクトの Python ラッパーを返します。このメソッドは C++ オブジェクトの Python ラッパーを返します。
 * 正しい参照カウントを行うのはプログラマの責任です。基本的には2つの方法があります。
 * を実装する方法があります：常に新しいPythonオブジェクトを返すか、 * そうすれば参照カウントは問題になりません。
 常に同じ Python オブジェクトを返すのであれば、参照カウントは問題 * ではありません。
 * その場合、参照カウンタは1つインクリメントされなければなりません。しかし、参照カウンタをインクリメントせずに常に同じ Python
 * オブジェクトを返すことは絶対に禁止されています。
 *
 * デフォルトの実装は 'None' を返します。
 */
PyObject *BaseClass::getPyObject(void)
{
    assert(0)；
    Py_Return；
}

void BaseClass::setPyObject(PyObject *)
{
    assert(0)；
}
```

### [src/Base/PyObjectBase.h] を参照してください。

このヘッダはPyObjectBaseクラスを定義し、c++クラスに対応するPython型を定義しやすくします。例えば、純粋なC++クラスのMatrixとMatrixPyがあります。

`typedef PythonClassObject<Base::Vector2dPy> Vector2d;` , これは pybind11 の `py::class_<T>` に対応します。

Py_Header はマクロ関数で、 `PyObject` は python C API のヘッダである `<python.h>` で定義されています。


```cpp
/** PyObjectBase クラスは Python の型としてクラスをエクスポートします。
 * PyObjectBase クラスは、クラスを Python 型としてエクスポートします。
 * PyObjectBase は python 名前空間にエクスポートする必要があるすべての C++ クラスの基底クラスです。

クラス BaseExport PyObjectBase : public PyObject
{
    /** python.h の Py_Header 構造体。
     * すべての PyObjectBase オブジェクトは Python オブジェクトでもあります。そのため
     * すべての Python C-Library 関数を PyObjectBase オブジェクトでも使用できます。
     */
    Py_Header

// Py_Headerの定義：
//これは各 PyC++ クラスの最初の行でなければなりません。
#define Py_Header
public：                                                     \
    static PyTypeObject Type; \
    static PyMethodDef Methods[];  \
    static PyParentObject Parents[];  \
    virtual PyTypeObject *GetType(void) {return &Type;}.     \
    virtual PyParentObject *GetParents(void) {return Parents;}.
```

### Type と BaseClass への Python インタフェース

[src/Base/BaseClassPyImp.cpp] を参照してください。

[src/Base/TypePyImp.cpp]を参照してください。



**********************************************

## 単位と量のシステム

### 単位と数量に関する一般的なウィキ

https://wiki.freecadweb.org/Quantity
https://wiki.freecadweb.org/Units

https://wiki.freecadweb.org/Expressions

関連クラス

Base::Unit`：  単位系、7つの基本単位のべき乗が配列に保存される。例: [1, 0, -1, 0, 0, 0, 0].

UnitsSchmes`: SI 単位系、CAD 内部単位系、帝国単位系の基本クラス。

Base::Quantity` : 物理量を定義するための値と量のペア

`Base::ExpressionParser`: 量と単位の変換

Gui::InputFiled`：`Gui::ExpressionLineEdit`を実装しており、Qtの`Gui::LineEdit`に対応している。

単位と量のシステムはQStringとpythonだけに依存しているので、FreeCADの外でも再利用できます。



### 単位系

SIには7つの基本単位がありますが、FreeCADでは派生単位である*密度*を定義しました。

[src/Base/Unit.h].

```cpp
struct UnitSignature{
    int32_t Length:UnitSignatureLengthBits；
    int32_t Mass:UnitSignatureMassBits；
    int32_t 時間:UnitSignatureTimeBits；
    int32_t 電流:UnitSignature電流Bits；
    int32_t 熱力学温度:UnitSignatureThermodynamicTemperatureBits；
    int32_t 物質量:UnitSignatureAmountOfSubstanceBits；
    int32_t ルミノーズ強度:UnitSignatureLuminoseIntensityBits；
    int32_t 角度:UnitSignatureAngleBits；
    int32_t Density:UnitSignatureDensityBits；
};
```

定義済みの静的単位型があります：静的単位長さ; ... 静的単位応力;`。



### 単位スキーマはいくつありますか？

MKS単位系は、メートル、キログラム、秒（MKS）を基本単位とする物理的な測定体系である。1889年に採用されたMKS単位系は、商業や工学におけるセンチメートル・グラム・秒単位系（CGS）を継承した。

[src/Base/UnitsSchema.h].

```cpp
    /** 単位系 */
enum class UnitsSystem { 以下のようになります。
    SI1 = 0 , /** 内部 (mm,kg,s) SI システム (http://en.wikipedia.org/wiki/International_System_of_Units) */
    SI2 = 1 , /** MKS (m,kg,s) SI システム */.
    Imperial1 = 2, /** インペリアルシステム (http://en.wikipedia.org/wiki/Imperial_units) */.
    ImperialDecimal = 3, /** インペリアルで長さはインチのみ */
    Centimeters = 4, /** 長さはすべてセンチメートル単位、面積と体積は平方メートル/立方メートル単位 */
    ImperialBuilding = 5, /** すべての長さをフィート＋インチ＋分数で表す */
    MmMin = 6, /** 長さはmm単位、速度はmm/min単位。角度は度。小さな部品やCNCに便利。
    ImperialCivil = 7, /** 長さ（フィート）、速度（フィート/秒）。北米の土木工学で使用 */
    NumUnitSystemTypes // 最後の項目でなければならない！
};
```

1: 内部 (mm/kg/s)
2: MKS (m/kg/s)
3: 米国慣習 (in/lb)

MKS単位系は、メートル、キログラム、秒（MKS）を基本単位とする物理的な測定システムである。

CADプログラムでは、伝統として長さの単位ミリメートルを除き、内部的にSI単位を使用しています。  したがって、"UnitsSchemaInternal" 圧力や面積のような多くの派生単位は、MKS SI単位スキーマとは異なるデフォルト単位を持ちます。

### 単位と数量の登録

例えば、[pull request #2863](https://github.com/FreeCAD/FreeCAD/pull/2863/commits/a8ad6d1ffe7cc88d6cb19355e3975d1cc591384a), "ガウス、エルステッド、ウェーバーの単位をサポートするのは賢明か?".  このプルリクエストは3つの量とその単位をFreeCADに登録します。

#### 基本単位記号の式パーサ

[src/Base/QuantityParser.l]を参照してください。
G" yylval = Quantity::Gauss; return UNIT; // Gauss (1 G = 1e-4 T)`.

[src/App/ExpressionParser.sh]を参照してください。
いくつかのファイルは手動でコーディングする代わりに生成されます。

```bash
flex -o lex.ExpressionParser.c < ExpressionParser.l
bison -o ExpressionParser.tab.c ExpressionParser.y
```

[src/App/ExpressionParser.l]を参照してください。

> "G" COUNTCHARS; yylval.quantity.scaler = Quantity::Gauss; yylval.quantity.unitStr = yytext; return UNIT; // ガウス (1 G = 1e-4 T)

どのように[src/Base/ExpressionParser.y]を更新すべきか、明確ではありません。

#### 単位と量の登録

[src/Base/Quantity.cpp] を参照してください。
量 Quantity::Gauss (1e-4 ,Unit(0,1,-2,-1)); // 1 G = 1e-4 T`.

[src/Base/Quantity.h] `static Quantity Gauss;`.
静的 Quantity Gauss;`.

[src/Base/Unit.h] `static Unit MagneticFluxData;`.
静的単位 MagneticFluxDensity;`.
[src/Base/Unit.cpp] `static Unit::MagneticFlux Density;`.
単位::磁束密度(0,1,-2,-1);`.

[src/Base/UnitsSchemaInternal.cpp] `Unit::MagneticFluxDensity(0,1,-2,-1);`.

``

[src/Base/UnitsSchemaMKS.cpp]を参照してください。

``

[src/Gui/DlgUnitsCalculatorImp.cpp] を参照してください。
<<< Base::Unit::MagneticFluxDensity`.



最後に、FreeCAD python システムに登録します。

[src/App/FreeCADInit.py]を実行します。
`App.Units.Gauss = App.Units.Quantity('G')`.

注意：すべての量が新しい単位を登録する必要があるわけではありません。例えば、速度単位は長さと時間の派生（計算）単位で、"mm/s "です。

### 単位変換

スキーマ間の単位変換は `schemaTranslate` 関数によって有効になります。

QString UnitsSchemaInternal::schemaTranslate(const Quantity &quant, double &factor, QString &unitString)`.

注意

> UnitsSchemaMKS "と "UnitsSchemaInternal "は単位変換をサポートするために実装する必要があります。  **このノートを書いている時点では、FreeCAD**ではインペリアルスキーマは不完全です。



UnitsSchemaInternal.cppとUnitsSchemaMKS.cppはほとんど同じです。

https://github.com/FreeCAD/FreeCAD/blob/master/src/Base/UnitsSchemaInternal.cpp

```cpp
else if (unit == Unit::DynamicViscosity) { 以下のようにします。
    unitString = QString::fromLatin1("kg/(m*s)")；
    factor = 0.001；
}
```

https://github.com/FreeCAD/FreeCAD/blob/master/src/Base/UnitsSchemaMKS.cpp
```cpp
else if (unit == Unit::DynamicViscosity) { 以下のようにします。
    unitString = QString::fromLatin1("kg/(m*s)")；
    factor = 0.001；
}
```
  


### 単位の GUI ウィジェット

Gui::InputFiled`はC++のクラスで、`Gui::ExpressionLineEdit`を実装しています。Python側では、クラスタイプは `PySide2.QtWidgets.QLineEdit` で、これは `value` と `unit` に直接アクセスできないことを意味します。

    #print(type(input_filed)) # PySide2.QtWidgets.QLineEdit は C++ 型の Gui::InputField ではない。
    #print(input_widget.text()) # "値と単位"



### 単位が関係する他の場所

フェムモジュール：マテリアルエディタは、マテリアルのプロパティをロードして編集することができます。

[src/Mod/Fem/femguiobjects/_ViewProviderFemMaterial.py] を参照してください。

Materialモジュール：  





## ベースモジュールの他のクラス

### [src/Base/Persistence.h] を参照してください。

XML文字列へのクラスインスタンスの保存と復元

### [src/Base/Parameter.h] 設定ファイルの IO

FreeCAD の実行ファイルは、起動時にコマンドライン引数として設定ファイルを受け取り、FreeCAD の初期化と動作を制御します。  しかし、この目的のために、json、toml(ini)、yaml、xml のような広く利用可能な他のサードパーティの設定ファイル形式があります。

### GeoFeature：すべての幾何学ドキュメントオブジェクトの基本クラス

```cpp
void GeoFeature::transformPlacement(const Base::Placement &transform)
{
    Base::Placement plm = this->Placement.getValue()；
    plm = transform * plm；
    this->Placement.setValue(plm)；
}
```



### [src/Base/Sequencer.h] 進捗報告クラス

try-catchブロックでの*Sequencer*の正しい使い方、公式ドキュメントより抜粋

```cpp
#include <Base/Sequencer.h>.
void runOperation()；
void myTest()
{
  try{
     runOperation()；
  } catch(...) {
     // プログラマはここでシーケンサーを停止するのを忘れています。
     // SequencerLauncher がそのスコープを離れると、オブジェクトは自動的に破壊され、 
     // 実行中のシーケンサーを停止します。
  }
}
void runOperation()
{
  // スタック上にインスタンスを作成する (ヒープ上のどの項にも作成しない)
  SequencerLauncher seq("my text", 10)；
  for (int i=0; i<10; i++)
  {
    // 何かをする (例えば、ここで例外をスローする)
    ...
    seq.next ()；
  }
}
```


###

## App フォルダ内のヘッダーファイル一覧

[このセクションはpythonスクリプトによって生成されます。

***********************************************************



### データクラス最下階層

+ PropertyとPropertyContainer: `double`型やSTL型のようなC++組み込み型の薄いラッパーで、永続化レイヤーである。  これらのほとんどは `PropertyEditor` GUIで編集できる。
+ Extension と ExtensionContainer: 中間レベルで、いくつかの機能を提供できるプロパティ群。
+ DocumentObject：GUIのツリー構造で表示される1つのオブジェクトに対応する。
+ Document（DocumentObjectコンテナとして）：高レベル、ファイルIOレイヤ。

Appモジュールの主な機能は、Model-View設計のためのデータモデル部分である。モデル-データのトランザクション（アンドゥ）と永続化はPropertyフレームワークによって行われる。Document`はVisual C++ 6時代の名前で、"Model-data-collection "のことである。

### FCStdファイルフォーマット

.FCStd`はFreeCADの標準的なデータファイル形式であり、要するに、標準的なzipコンテナである。

+ プロパティを保存する`App::Document`クラスに対応するDocument.xmlです。

+ Gui::Document`クラスに対応するGuiDocument.xmlにはレンダリングプロパティが含まれています。

+ OpenCASCADE BREP Shape 用の *.brp がいくつかあります。

+ その他

  詳細は https://wiki.freecadweb.org/File_Format_FCStd をご覧ください。



## プロパティフレームワーク

プロパティ・フレームワークの使用例については、Doxygenが生成したドキュメントを参照してください。しかし、モジュール開発者はそのような低レベルの詳細を知る必要はありません。

JavaやC#のリフレクション機構のようなものです。   
この機能は `App::PropertyContainer `クラスによって導入され、すべての派生クラスで使用できる。


これにより、（例えば`App::FeaturePy`で）pythonへの自動マッピングを行い、`Gui::PropertyEditor`でプロパティを抽象的に編集することがまず可能になります。

Python でのプロパティへのアクセスは、型変換（ダウンキャスト）のために `static_cast<>` を必要とする c++ よりも簡単です。

`App::Property* PropertyContainer::getPropertyByName(const char *name) const` は、c++とpythonで定義されたプロパティに対して動作します。

プロパティを追加するには、ADD_PROPERTY マクロを使用するか、動的プロパティを追加します。
```cpp
virtual App::Property * addDynamicProperty (const char *type, const char *name=0、
     const char *group=0, const char *doc=0, short attr=0, bool ro=false, bool hidden=false)
```



### [src/App/Property.h].

プロパティはPropertyContainerに属さなければなりません。

プロパティはPropertyContainerに属していなければなりません。

```cpp
クラス AppExport Property : public Base::Persistence
{
    typesystem_header_with_override()；
...
    
	/// プロパティの値を設定する
    virtual void setPathValue(const App::ObjectIdentifier & path, const boost::any & value)；
    /// プロパティの値を取得
    virtual const boost::any getPathValue(const App::ObjectIdentifier & path) const；
...
    /** プロパティのステータスビット
     * 最初の8ビットは基本システムで使用され、残りのビットは子孫クラスで使用されます。
     * 子孫クラスで使用することができます。
     * ビットとその意味を以下に示す：
     * 0 - オブジェクトは「タッチされた」とマークされます。
     * 1 - オブジェクトは「不変」とマークされます。
     * 2 - オブジェクトは'read-ony'とマークされます。
     * 3 - オブジェクトは'hidden'とマークされます。
     */
    std::bitset<32> StatusBits；
...
private：
    PropertyContainer *father；
```

note: `boost::any` と `boost::filesystem::path` は C++17 に含まれる予定です。

### プロパティのマクロ関数

いくつかのマクロ関数が [src/App/Property.h] に導入され、Property 派生クラスで使用されます。

- PROPERTY_HEADERはTYPESYSTEM_HEADER()を含んでいるので、自動的に型システムに追加されます。

- ADD_PROPERTY(_prop_,_defaultval_)は、cppファイルで使用されています。

- ADD_PROPERTY_TYPE(_prop_, _defaultval_, _group_,_type_,_Docu_), _Docu_はユーザー用のdocstringツールチップ、 _group_は "Data"、 _type_はenum PropertyType、Prop_Noneは最も一般的な型です。

- PROPERTY_SOURCE(_class_,_parentclass_)はcppファイルのコンストラクタの1行目で使用されています。

- property_source_abstractです、
- TYPESYSTEM_SOURCE_TEMPLATE(_class_)です、
- PROPERTY_SOURCE_TEMPLATE(_class_, _parentclass_)

### [src/App/PropertyStandard.h] 一般的なC++データ型のプロパティ

PropertyBool、PropertyInteger (long)、PropertyString (utf8/std::string)、PropertyFloat (double)、PropertyPath (boost::filesystem::path)、PropertyFont、PropertyColor、PropertyMaterial、PropertyUuid、PropertyStringLists、PropertyMap(std::map<std::string, std::string>)`。

`PropertyIntegerConstraint`は `PropertyInteger` に上界と下界を設定したものである。

```cpp
struct Constraints { long LowerBound, UpperBound, StepSize; }；
void setConstraints(const Constraints* sConstraint); /// 制約を取得する struct Constraints* getConstraints(void) const；
```

PropertyList*派生クラスでは、`std::vector<>`参照で値の設定と取得が可能です。
setValues(std::vector<T>&)`, std::vector<T>& getValues()`.

*PropertyFloatList*は実際には倍精度データ(float64)を保持します。

はプロパティとしてキー/値リストを実装しています。キーはASCII、値はUTF8として保存する。

### *PropertyEnumeration*, [src/App/Enumeration.h]を参照してください。

App::Enumerationは、この列挙プロパティを保持するためのプライベートデータ構造です。

- setEnums() NULL 終了文字列配列を受け入れる

- 文字列配列 `const char * getValueAsString(void) const;`.

PropertyEditorのComboboxで使用することができます。

src/Mod/Fem/App/FemMeshShapeNetgenObject.cpp] の例を参照してください。

```cpp
#include <App/PropertyStandard.h> を参照してください。
const char* FinenessEnums[]= {"VeryCoarse", "Coarse", "Moderate", "Fine", "VeryFine", "UserDefined",NULL}；
...
ADD_PROPERTY_TYPE(Fineness,(2), "MeshParams",Prop_None, "Fineness level of the mesh")；
Fineness.setEnums(FinenessEnums)；
```

### ジオメトリ関連のプロパティクラス

PropertyVector、PropertyMatrix、PropertyPlacement: プロパティエディタでアクセスできます。

src/App/PropertyGeo.cpp] を参照してください。

プロパティ・エディタでアクセスできるプロパティは、[src/App/PropertyGeo.cpp] を参照してください。
プロパティComplexGeoData : public App::PropertyGeometry`.

### ファイル関連のプロパティクラス

src/App/PropertyFile.cpp] で定義されているクラスを参照してください。

```cpp
App::PropertyPath
App::PropertyFile
App::PropertyFileIncluded
```


### 関連リンク

[src/App/PropertyLinks.cpp] このドキュメント内の他のドキュメントオブジェクトへのリンク。例えば、FemMeshObjectはPartオブジェクトへのリンクを持っています。

例えば、パーツの面など、サブフィーチャーへのリンクが必要なシナリオがあります。

### PropertyPythonObject


### 物理量の単位を持つプロパティ

[src/App/PropertyUnits.cpp]を参照してください。

```cpp
TYPESYSTEM_SOURCE(App::PropertyDistance, App::PropertyQuantity)；

PropertyDistance::PropertyDistance()
{
     setUnit(Base::Unit::Length)；
}
```



### [src/App/PropertyContainer.h] 以下のようにする。

```cpp
enum PropertyType
{
  Prop_None = 0、
  Prop_ReadOnly = 1、
  Prop_Transient = 2、
  Prop_Hidden = 4、
  Prop_Output = 8
};

struct AppExport PropertyData
{
  構造体 PropertySpec
  {
    const char* Name；
    const char * Group；
    const char * Docu；
    short Offset,Type；
  };
  // すべてのプロパティのベクトル
  std::vector<PropertySpec> propertyData；
  const PropertyData *parentPropertyData；

  void addProperty(const PropertyContainer *container,const char* PropName, Property *Prop, const char* PropertyGroup= 0, PropertyType = Prop_None, const char* PropertyDocu= 0 )；

  const PropertySpec *findProperty(const PropertyContainer *container,const char* PropName) const；
  const PropertySpec *findProperty(const PropertyContainer *container,const Property* prop) const；

  const char* getName (const PropertyContainer *container,const Property* prop) const；
  short getType (const PropertyContainer *container,const Property* prop) const；
  short getType (const PropertyContainer *container,const char* name) const；
  const char* getGroup (const PropertyContainer *container,const char* name) const；
  const char* getGroup (const PropertyContainer *container,const Property* prop) const；
  const char* getDocumentation(const PropertyContainer *container,const char* name) const；
  const char* getDocumentation(const PropertyContainer *container,const Property* prop) const；

  Property *getPropertyByName(const PropertyContainer *container,const char* name) const；
  void getPropertyMap(const PropertyContainer *container,std::map<std::string,Property*> &Map) const；
  void getPropertyList(const PropertyContainer *container,std::vector<Property*> &List) const；
};

class AppExport PropertyContainer: public Base::Persistence
{
private：
  // 禁止
  PropertyContainer(const PropertyContainer&)；
  PropertyContainer& operator = (const PropertyContainer&)；

private：
  static PropertyData propertyData；
};

```

### GUIモジュールのPropertyEditor

DocumentObject`のプロパティはGUIモードの`PropertyEditor`ビューで編集することができる。

バージョン0.19では、PropertyEditor GUIで動的プロパティを追加できるようになりました。[ドキュメントオブジェクトに動的プロパティを追加する方法](https://www.freecadweb.org/wiki/images/3/3d/Custom-property.gif)のアニメーションをご覧ください。

#### プロパティの命名と PropertyEditor

プロパティ名は "ThisPropertyName "のように大文字で始まるべきで、プロパティエディタでは "This Property Name "として表示されます。
プロパティ名を大文字で分割し、スペースを挿入するロジックは確かにあります。しかし、それは視覚的な目的のためだけであり、プロパティ値の変更には影響しません。

### プロパティ・フレームワークの再考


#### `std::any`をベースにしたPropertyContainer

FreeCADのプロパティフレームワークにインスパイアされているが、`App::Property`から派生したプロパティクラスを宣言することなく、任意のデータを保持することができる。 リンクは、"Parallel preprocessor "がオープンソース化された時点で更新される。

************************************************



## 拡張フレームワーク

### 拡張フレームワークの紹介

このフレームワークは0.17で追加されました。フォーラムディスカッションの機能アナウンスを参照してください：
[開発者向け機能: 拡張機能](https://forum.freecadweb.org/viewtopic.php?f=9&t=17863)

FreeCAD では、Python インターフェース API を提供するために、継承は通常チェーンで行われます。

<https://github.com/FreeCAD/FreeCAD/blob/master/src/App/ExtensionContainer.h#L36>

 * プロパティの永続化が処理され、保存と復元がすぐに行えます。
 * オブジェクトの python API は、拡張の python API で拡張されます。
 * 拡張は c++ と python の両方から追加することができます。

### C++ での拡張フレームワークの使用法


オブジェクトに拡張機能を追加するには、1つの制約に従わなければなりません。

```cpp
class AppExport AClass : public App::DocumentObject, public App::FirstExtension, public App::SecondExtension { アプリケーションエクスポート ACクラス : public App::DocumentObject, public App::FirstExtension, public App::SecondExtension
    PROPERTY_HEADER_WITH_EXTENSIONS(App::AClass)；
    ...
};

 // 実装ソースファイルでは
 PROPERTY_SOURCE_WITH_EXTENSIONS(App::AClass、App::DocumentObject)
 // コンストラクタで拡張機能を初期化する必要があります。
 AClass::AClass(void) { // 拡張機能はコンストラクタで初期化する必要があります。
    FirstExtension::initExtension(this)；
    SecondExtension::initExtension(this)；
 }
```

は適切ではない、

https://github.com/FreeCAD/FreeCAD/blob/master/src/App/Path.h コピー＆ペースト

### Python における拡張フレームワークの使用法

トド

### 拡張フレームワークの実装

```cpp
class AppExport ExtensionContainer : public App::PropertyContainer
    

class AppExport Extension { { App::Extension
    EXTENSION_PROPERTY_HEADER(App::Extension); // プロパティアクセサを提供します。
};
// いくつかのマクロ関数

/**
 * Python の汎用拡張クラスです。
 * クラスが Python 拡張モジュールとして動作するようにします。
 */
テンプレート <class ExtensionT>
class ExtensionPythonT : public ExtensionT
{
    EXTENSION_PROPERTY_HEADER(App::ExtensionPythonT<ExtensionT>)；

public：
    typedef ExtensionT 継承；
    
    ExtensionPythonT() { 拡張子Tを継承します。
        ExtensionT::m_isPythonExtension = true；
        ExtensionT::initExtensionType(ExtensionPythonT::getExtensionClassTypeId())；
        
        EXTENSION_ADD_PROPERTY(ExtensionProxy,(Py::Object()))；
    }
    virtual ‾ExtensionPythonT() { }.
    }

    PropertyPythonObject ExtensionProxy；
};
```



プロパティとメソッドにアクセスするためのプロキシです、

public ExtensionT`


### アセンブリモジュールの準備としての `App::Link`

`App::Link`については、[Assembly3モジュールにおけるApp::Linkの説明](https://github.com/realthunder/FreeCAD_assembly3/wiki/Link) を参照してください。
"Assembly3 "はrealthunder氏によってPythonで書かれたアセンブリワークベンチで、"Link "機能を利用している。

+ 個々のオブジェクトやグループへのリンクだけでなく、サブオブジェクト（例えばグループの子オブジェクト）やサブジオメトリ要素（例えば面）へのリンクも可能です。

+ プログラマーは、`App::LinkBaseExtension`と`Gui::ViewProviderLink`を使用して、非常に柔軟に独自のLinkタイプのオブジェクトを作成することができます。

+ また、`App::LinkBaseExtensionp` を使用することもできます。

```cpp
class AppExport LinkBaseExtension : public App::DocumentObjectExtension
{
    EXTENSION_PROPERTY_HEADER_WITH_OVERRIDE(App::LinkExtension)；
    
    ...// 多くのマクロ関数は `LINK_PARAM` で始まる。
      protected：
          std::vector<Property *> props；
          std::unordered_set<const App::DocumentObject*> myHiddenElements；
          mutable std::vector<std::string> mySubElements；
          mutable std::string mySubName；
      
          std::unordered_map<const App::DocumentObject*、
              boost::signals2::scoped_connection> plainGroupConns；
      
          long myOwner；
      
          mutable std::unordered_map<std::string,int> myLabelCache; // ラベルベースのサブネーム検索用
          mutable bool enableLabelCache；
      
          bool hasOldSubElement；
      };

```

+ App::Link, App::LinkElement, App::LinkGroup


  ```cpp
  class AppExport Link : public App::DocumentObject, public App::LinkExtension
    {
        PROPERTY_HEADER_WITH_EXTENSIONS(App::Link)；
      
  class AppExport LinkExtension : public LinkBaseExtension { PROPERTY_HEADER_WITH_EXTENSIONS(App::Link)
  
  typedef App::FeaturePythonT<Link> LinkPython；
  
  class AppExport LinkGroup : public App::DocumentObject, public App::LinkBaseExtension { { App::DocumentObject, public App::LinkBaseExtension
      PROPERTY_HEADER_WITH_EXTENSIONS(App::LinkGroup)；
  ```

  

## ドキュメントオブジェクトフレームワーク

Document-View-Observerは "Model-View-Controller "パターンと密接に関連している。

**App::Document**, **Gui::ViewProvider**, **App::DocumentObserver**.

### [src/App/Document.h] を参照してください。

- `class AppExport Document : public App::PropertyContainer`.

> CADモデルのメタ情報をプロパティとして格納します：著者、日付、ライセンスなど。

- DocumentObject のコンテナである *DocumentObjectGroup* を含みます。
- ネイティブ FreeCAD ファイルフォーマットへの保存と読み込み: `Property<T>` XML ノードの zip フォルダ、PropertyLink ( パス)
- ファイルのエクスポートとインポート機能。
- AddDocumentObject()/remDocumentObject()`.
- データベースと同様のトランザクションサポート  元に戻す
- recompute()：
- viewProvider: 3Dシーンのビューを更新する

### [src/App/DocumentObject.h].


DocumentObjectは、Documentで扱われるすべてのデータClassの基本クラスです。

<https://www.freecadweb.org/api/DocumentObject.html>を参照してください。重要なメソッド（`App::PropertyContainer`のメソッドを除く）を抜粋してあります：

- state`列挙。

```cpp
enum ObjectStatus { オブジェクトの状態
  Touch = 0, Error = 1, New = 2, Recompute = 3、
  リストア = 4, エキスパンド = 16
}
```

- setstate__(value)` はこのオブジェクトのカスタム属性を文字列として保存することができる。
- `touch()` はこのオブジェクトに再計算のマークを付けます。
- `purgeTouched()` はこのオブジェクトの再計算するフラグを削除します。
- execute()` このメソッドはオブジェクトの作成時とドキュメントの再計算時に実行されます。

#### 実装[src/App/DocumentObject.h] を参照してください。

FreeCAD の以前のバージョン、例えば 0.16 では、`App::DocumentObject` は `App::PropertyContainer` から直接派生しています。  クラス AppExport DocumentObject: public App::PropertyContainer` .後にExtensionフレームワークが導入されると、継承の連鎖が長くなります。

`クラス AppExport TransactionalObject : public App::ExtensionContainer` 。

`クラス AppExport ExtensionContainer: public App::PropertyContainer` .

`クラス AppExport TransactionalObject : public App::ExtensionContainer`

および[src/App/DocumentObject.cpp]。

```cpp
protected:
    /* 通常、このメソッドは Document::recompute() の処理で呼び出されます。
      * 通常、このメソッドは Document::recompute() の処理で呼び出されます。
      * execute()では、リンクされたオブジェクトとオブジェクト自身のプロパティからのデータで、出力プロパティが再計算されます。
      */
    virtual App::DocumentObjectExecReturn *execute(void)；

    /* ドキュメントオブジェクトのステータスビット
     * 最初の8ビットは基本システムで使用され、残りは子孫クラスで使用されます。
     * 残りのビットは子孫クラスで使用することができます。
     * ビットとその意味は以下の通りです：
     * 0 - オブジェクトは「タッチされた」とマークされます。
     * 1 - オブジェクトは「エラー」としてマークされます。
     * 2 - オブジェクトは「新しい」とマークされます。
     * 3 - オブジェクトは「recompute（再計算）」とマークされます。
     * 4 - オブジェクトは'restoring'とマークされる。
     * 5 - 予約済み
     * 6 - 予約済み
     * 7 - 予約済み
     * 16 - オブジェクトはツリービューで'expanded'とマークされる。
     */
    std::bitset<32> StatusBits；

protected:// 属性
    Py::Object PythonObject；
    /// このオブジェクトが属するドキュメントへのポインタ
    App::Document* _pDoc；
    // ドキュメントとドキュメントオブジェクトの再ラベルを追跡するためのコネクション
    boost::BOOST_SIGNALS_NAMESPACE::scoped_connection onRelabledDocumentConnection；
    boost::BOOST_SIGNALS_NAMESPACE::scoped_connection onRelabledObjectConnection；

    /// 古いラベル; 式の名前変更に使用
    std::string oldLabel；

    // ドキュメント名文字列へのポインタ (パフォーマンス用)
    const std::string *pcNameInDocument；
```

### ドキュメントオブジェクトのオブザーバーとサブジェクトパターン

DocumentObserver クラスと DocumentObjectObserver クラスは Document/DocumentObject の変更/追加/削除を監視し、slotFunction() をトリガーします。
```cpp
テンプレート <class MessageType> クラス Subject；
テンプレート <class _MessageType> クラス Observer
```
**よく知られた Observer Design Pattern の実装です。** FCSubject を継承したオブザーバオブジェクトは、変更があった場合、すべてのオブザーバを呼び出します。オブザーバークラスはオブザーバーオブジェクトにアタッチする必要があります。

DocumentObserverクラスは、ドキュメントの内部で起こることをリッスンするクラスを書くステップを単純化します。  これは、観測オブジェクトが変更されたときに通知を受ける必要があるクラスにとって非常に便利です。

```cpp
    void attachDocument(Document*)；
    /* 与えられたドキュメントが開かれようとしているか、閉じられようとしているかをチェックします。
    virtual void slotDeletedDocument(const App::Document& Doc) {} /* 新しいオブジェクトがオープンされたかどうかをチェックします。
    /* 新しいオブジェクトが追加、削除、変更されたかどうかをチェックします。*/
    virtual void slotCreatedObject(const App::DocumentObject& Obj) {} /* 新しいオブジェクトが追加、削除、変更されたかどうかをチェックします。
```

### App::DocumentObjectExecReturn

ファイル[src/App/DocumentObject.h]で定義されています。

```cpp
/** 機能実行のためのオブジェクトを返す
*/
class AppExport DocumentObjectExecReturn
{
public：
    DocumentObjectExecReturn(const std::string& sWhy, DocumentObject* WhichObject=0)
        : Why(sWhy), Which(WhichObject)
    {
    }
    DocumentObjectExecReturn(const char* sWhy, DocumentObject* WhichObject=0)
        : Which(WhichObject)
    {
        if(sWhy)
            Why = sWhy；
    }

    std::string Why；
    DocumentObject* Which；
};
```


### 特集パイソン

```cpp
DocumentObjectExecReturn *FeaturePythonImp::execute()
{
    // プロキシオブジェクトの execute メソッドを実行します。
    Base::PyGILStateLocker をロックします；
    try { // プロキシオブジェクトの
        Property* proxy = object->getPropertyByName("Proxy")；
        if (proxy && proxy->getTypeId() == PropertyPythonObject::getClassTypeId()) { プロキシオブジェクトを実行します。
            Py::Object feature = static_cast<PropertyPythonObject*>(proxy)->getValue()；
            if (feature.hasAttr("__object__")) { { Py::Callable method(feature.hasAttr("__object__"))
                Py::Callable method(feature.getAttr(std::string("execute")))；
                Py::Tuple args；
                method.apply(args)；
            }
            else {
                Py::Callable method(feature.getAttr(std::string("execute")))；
                Py::Tuple args(1)；
                args.setItem(0, Py::Object(object->getPyObject(), true))；
                method.apply(args)；
            }
        }
    }
    catch (Py::Exception&) { } }.
        Base::PyException e; // Pythonのエラーテキストを取り出す
        e.ReportException()；
        std::stringstream str；
        str << object->Label.getValue() << ": " << e.what()；
        return new App::DocumentObjectExecReturn(str.str())；
    }

    return DocumentObject::StdReturn；
}
```

### FeaturePythonPy テンプレートクラス

このテンプレートは、DocumentObjectPyのように、ドキュメントオブジェクトの派生クラスをpythonに公開するのに役立ちます。
詳細は、Fem モジュールのコード解析と Python のラッピングの章を参照してください。

```cpp
テンプレート <class FeaturePyT>
class FeaturePythonPyT : public FeaturePyT
{
public：
    static PyTypeObject Type；
    static PyMethodDef Methods[]；

public：
    FeaturePythonPyT(DocumentObject *pcObject, PyTypeObject *T = &Type)；
    virtual ~FeaturePythonPyT()；

    /** @pythonオブジェクトのメソッドのコールバックとインプリメンターを指定します。
    //@{
    static int __setattr(PyObject *PyObj, char *attr, PyObject *value)；
    /// addProperty()メソッドのコールバック
    static PyObject * staticCallback_addProperty (PyObject *self, PyObject *args)；
    /// addProperty() メソッドの実装子
    PyObject* addProperty(PyObject *args)；
    /// removeProperty() メソッドのコールバック関数
    static PyObject * staticCallback_removeProperty (PyObject *self, PyObject *args)；
    /// removeProperty() メソッドの実装子
    PyObject* removeProperty(PyObject *args)；
    /// supportedProperties() メソッドのコールバック関数
    static PyObject * staticCallback_supportedProperties (PyObject *self, PyObject *args)；
    /// supportedProperties()メソッドの実装を行います。
    PyObject* supportedProperties(PyObject *args)；
    //@}

    /// 特別な属性（動的な属性など）のゲッターメソッド
    PyObject *getCustomAttributes(const char* attr) const；
    /// 特別な属性（動的なものなど）のためのセッターメソッド
    int setCustomAttributes(const char* attr, PyObject *obj)；
    PyObject *_getattr(char *attr); // __getattr__ 関数
    int _setattr(char *attr, PyObject *value); // __setattr__ 関数

protected：
    std::map<std::string, PyObject*> dyn_methods；

private：
};

}// 名前空間 App
```

```cpp
#"FeaturePythonPyImp.inl" をインクルードする。// FeaturePythonPyTの型構造体
/// FeaturePythonPyTのメソッド構造体
template<クラス FeaturePyT>
PyMethodDef FeaturePythonPyT<FeaturePyT>::Methods[] = {
    ...
}

template <class FeatureT>
class FeaturePythonT : public FeatureT
{
    PROPERTY_HEADER(App::FeaturePythonT<FeatureT>)；
    ...

protected：
    virtual void onBeforeChange(const Property* prop) { FeatureT::onBeforeChange(prop); ...
        FeatureT::onBeforeChange(prop)；
        imp->onBeforeChange(prop)；
    }
    virtual void onChanged(const Property* prop) { インプ->onChanged(prop)。
        imp->onChanged(prop)；
        FeatureT::onChanged(prop)；
    }

private:
    imp->on-change(prop); } 

private: FeaturePythonImp* imp；
    DynamicProperty* props；
    PropertyPythonObject プロキシ；
};

```



### 式フレームワーク



### トランザクションフレームワーク

class AppExport TransactionObject : public Base::Persistence, トランザクション内のオブジェクトのエントリ

class AppExport Transaction : public Base::Persistence, ドキュメント内のアトミック操作

### 異なるモジュール内の同じ名前のクラス

App::Part Part:Part


`class AppExport Placement: public App::GeoFeature` データの再配置を処理する。グループ化も可能



***************************************************************************************


## FreeCADCmd の起動プロセス

## [src/Main/MainCmd.cpp]内のmain()関数のスケルトン


この cpp スクリプトは実行ファイル `freecadcmd` にコンパイルされ、FreeCAD モジュールのパスが sys.path に追加された python インタプリタにドロップされます。

```cpp
	int main()
	{
	    try {
	        // 初期化フェーズ ===========================
	        // FCのデフォルトの実行モードを設定し、コマンドプロンプトで開始します。
                //InitConfigでオーバーライドされていない場合...
	        App::Application::Config()["RunMode"] = "Exit"；

	        // アプリケーションを開始する
	        App::Application::init(argc,argv)；
	    }

	    // 実行フェーズ ===========================
	    App::Application::runApplication()；


	    // 終了フェーズ ===================================================================
	    Console().Log("FreeCADを終了します。")；

	    // 開いているドキュメントを閉じる
	    App::GetApplication().closeAllDocuments()；

	    // クリーンアップ
	    Application::destruct()；

	    Console().Log("FreeCAD completely terminatedn")；

	    return 0；
	}
```

### [src/Main/MainPy.cpp] を参照してください。

このcppファイルは、標準のpythonにインポートできるpythonモジュール "FreeCAD "にコンパイルされます。

このソースコードは、条件付きCマクロによって、異なるOSプラットフォーム、python 2または3のバージョンに対応します。
エラー、出力、ログのIOリディクションを設定します。

```cpp
PyMOD_INIT_FUNC(FreeCAD)
//void MainExport initFreeCAD() // バージョン 0.16 では関数名は
{
    
    App::Application::Config()["ExeName"] = "FreeCAD"；
    // ...
	// 共有dll/soのロード
	App::Application::init(argc,argv)；
}
```
この関数の最後に、モジュールが返される。

```cpp
#if PY_MAJOR_VERSION >= 3
    //PyObject* module = _PyImport_FindBuiltin("FreeCAD")；
    PyObject* modules = PyImport_GetModuleDict()；
    PyObject* module = PyDict_GetItemString(modules, "FreeCAD")；
    if (!module) { PyErr_SetString()
        PyErr_SetString(PyExc_ImportError, "Failed to load FreeCAD module!")；
    }
    return module；
#endif
```

### App::Application クラス

//アプリケーションのシングルトン・ポインタは *Application.cpp* ファイルでデクリアされる。
Application * Application::_pcSingleton = 0; //静的メンバ変数

```cpp
void Application::init(int argc, char ** argv) //static
{

// 1) シグナルハンドラのセットアップ

initTypes(); // 2) 後述のソースコード参照

initConfig(int argc, char ** argv) //std::map<std::string, std::string>.
// 3) 環境変数; LoadParameters()；

initApplication(); //4)下記参照
}

void Application::initTypes(void) //静的
{
    // 基本型
    Base::Type ::init()；
    Base::BaseClass ::init()；
    ... 他のすべての型

void Application::initApplication(void) //static
{
    // インタプリタとInitスクリプト ===========================================================
    // スクリプトの登録
    new ScriptProducer( "FreeCADInit", FreeCADInit )；
    new ScriptProducer( "FreeCADTest", FreeCADTest )；

    // アプリケーションを作成する
    if (!(mConfig["Verbose"] == "Strict"))Console().Log("Create Applicationn")；
    Application::_pcSingleton = new Application(0,0,mConfig)；

    // ユニットシステムのデフォルトを設定する
    ParameterGrp::handle hGrp = App::GetApplication().GetParameterGroupByPath
       ("User parameter:BaseApp/Preferences/Units")；
    UnitsApi::setSchema((UnitSystem)hGrp->GetInt("UserSchema",0))；

#if defined (_DEBUG)
    Console().Log("Application is built with debug informationn")；
#endif

    // initスクリプトの開始
    Console().Log("Run App init script scriptn")；
    Interpreter().runString(Base::ScriptFactory().ProduceScript("FreeCADInit"))；
}

```

### Python インタプリタの統合方法

```cpp
Application::Application(ParameterManager * /*pcSysParamMngr*/、
                         ParameterManager * /*pcUserParamMngr*/、
                         std::map<std::string,std::string> &mConfig)
    ://_pcSysParamMngr(pcSysParamMngr)、
    //_pcUserParamMngr(pcUserParamMngr)、
    _mConfig(mConfig)、
    _pActiveDoc(0)
{
    //_hApp = new ApplicationOCC；
    mpcPramManager["System parameter"] = _pcSysParamMngr；
    mpcPramManager["User parameter"] = _pcUserParamMngr；


    // Pythonバインディングの設定
    Base::PyGILStateLocker をロックします；
    PyObject* pAppModule = Py_InitModule3("FreeCAD", Application::Methods, FreeCAD_doc)；
    Py::Module(pAppModule).setAttr(std::string("ActiveDocument"),Py::None())；

    PyObject* pConsoleModule = Py_InitModule3("__FreeCADConsole__", ConsoleSingleton::Methods, Console_doc)；

    // 追加クラスの導入

    // 注: 私たち自身の型オブジェクトの初期化を終了するには、次のようにしなければなりません。

    // そうしないと、後でセグメンテーションフォールトに遭遇します。
    // この関数は型の基底クラスから継承されたスロットを追加します。

    //... 表示されていないコードもあります！

}

static void Application::runApplication()
{
    // コマンドライン・インターフェイスを通して与えられたすべてのファイルを処理する
    processCmdLineFiles()；

    if (mConfig["RunMode"] == "Cmd") { // コマンドラインインターフェースを実行する。
        // コマンドライン・インターフェイスを実行する
        Interpreter().runCommandLine("FreeCAD コンソールモード")；
    }
    else if (mConfig["RunMode"] == "Internal") { // 内部スクリプトを実行する。
        // 内部スクリプトを実行する
        Console().Log("内部スクリプトを実行中: \n")；
        Interpreter().runString(Base::ScriptFactory().ProduceScript(mConfig["ScriptFileName"].c_str()))；
    }
    else if (mConfig["RunMode"] == "Exit") { // 終了します。
        // 終了する
        Console().Log("Exiting on purposen")；
    }
    else {
        Console().Log("Unknown Run mode (%d) in main()?!?୨",mConfig["RunMode"].c_str())；
    }
}
```

*******************************************************************

## FreeCADGui 起動処理

### [src/Main/MainGui.cpp] の main()


このソースは "freecad "プログラムにコンパイルされ、FreeCAD GUIを起動します。

この main 関数は、[src/Main/MainCmd.cpp] と似ていますが、Gui モードと非 GUI モードの両方をサポートしています。
*App::Application::init(argc, argv); * と *App::Application::destruct(); * はまだ呼び出されます！

QCoreApplicationはWIN32用に定義されており、[src/Main/MainGui.cpp]を参照してください。

```cpp
int main()
{
    App::Application::init(argc, argv)；
    Gui::Application::initApplication(); // 余計な InitApplication()；
    // 'RunMode'が'Gui'に設定されている場合のみ、置換を行う
    if (App::Application::Config()["RunMode"] == "Gui")
            Base::Interpreter().replaceStdOutput()；

    を試す。
        if (App::Application::Config()["RunMode"] == "Gui")
            Gui::Application::runApplication()；
        else
            App::Application::runApplication()；
    }
    ...
    App::Application::destruct()；
}

```

### [src/Gui/Application.cpp]の `runApplication()` です。

Gui::Applicationのコンストラクタ：Pythonバインディングの設定

```cpp

/** QCoreApplication::notify() をオーバーライドして、Qt ウィジェットの例外を取得します。
 * イベントハンドラやスロットで処理されない例外を適切に取得します。
 */
クラス GUIApplication : public GUIApplicationNativeEventAware

void Application::runApplication(void)
{
    GUIApplication mainApp(argc, App::Application::GetARGV(), systemExit)；
    // アプリケーション・アイコンとウィンドウ・タイトルを設定する
    const std::map<std::string,std::string>& cfg = App::Application::Config()；
    ...
    QCoreApplication::addLibraryPath(plugin)；
    ...//コンフィグ、スタイルシートの設定
    Application app(true); // Gui::Applicationのコンストラクタを通過する価値がある。
    メインウィンドウ mw；
    mw.setWindowTitle(mainApp.applicationName())；

    // Inventorサブシステムを開始する
    SoDB::init()；
    SIM::Coin3D::Quarter::Quarter::init()；
    SoFCDB::init()；

    // GUI initスクリプトを実行する
    try { 以下のスクリプトを実行します。
        Base::Console().Log("Run Gui init scriptn")；
        Base::Interpreter().runString(Base::ScriptFactory().ProduceScript("FreeCADGuiInit"))；
    }
    catch (const Base::Exception& e) { { Base::Console().Exception("FreeCADGuiInit").
        Base::Console().Error("Error in FreeCADGuiInit.py: %sn", e.what())；
        mw.stopSplasher()；
        を投げる；
    }
    // スプラッシュスクリーンを停止し、すぐにアクティブウィンドウを設定します。
    // Qt 用 Python バインディングを使用するスクリプトの場合
    mw.stopSplasher()；
    mainApp.setActiveWindow(&mw)；
    ...
    app.activateWorkbench(start.c_str())；
    ...
    // アプリケーション・イベント・ループの実行
    Base::Console().Log("Init: Entering event loopn")；
    try {
        std::stringstream s；
        s << App::Application::getTempPath() << App::GetApplication().getExecutableName()
          << "_" << QCoreApplication::applicationPid() << ".lock"；
        // PIDでロックファイルを開く
        Base::FileInfo fi(s.str())；
        Base::ofstream lock(fi)；
        boost::interprocess::file_lock flock(s.str().c_str())；
        flock.lock()；

        int ret = mainApp.exec()；
        if (ret == systemExit)
            throw Base::SystemExitException()；

        // クラッシュした場合、既存のロックファイルを見ることができます。
        // 次の再起動時に既存のロックファイルを確認し、必要であればドキュメントの修復を試みます。
        flock.unlock()；
        lock.close()；
        fi.deleteFile()；
    }

}
```

### 【src/Main/FreeCADGuiPy.cpp


このcppファイルはpythonモジュール "FreeCADGui "にコンパイルされ、標準のpythonにインポートすることができます。

GUIによるFreeCADの起動の詳細については、[src/Gui/Application.cpp]を参照してください。

GuiThreadクラスが定義されています。
```cpp
構造体 PyMethodDef FreeCADGui_methods[] = {
    {"showMainWindow",FreeCADGui_showMainWindow,METH_VARARGS、
     "showMainWindow() -- メインウィンドウを表示する"
     "メインウィンドウが存在しない場合、作成される"}、
    {"exec_loop",FreeCADGui_exec_loop,METH_VARARGS、
     "exec_loop()" -- イベントループを開始する。
     "注意：これはイベントループが終了するまで呼び出しをブロックします"}、
    {"setupWithoutGUI",FreeCADGui_setupWithoutGUI,METH_VARARGS、
     "setupWithoutGUI() -- このモジュールを起動せずに使用する。
     「イベントループやGUIを表示することなくこのモジュールを使用する、｝
    {"embedToWindow",FreeCADGui_embedToWindow,METH_VARARGS、
     "embedToWindow() -- メインウィンドウを別のウィンドウに埋め込む、｝
    {NULL, NULL}.  /* センチネル */
};


PyMODINIT_FUNC initFreeCADGui()
{
    try {
        Base::Interpreter().loadModule("FreeCAD")；
        App::Application::Config()["AppIcon"] = "freecad"；
        App::Application::Config()["SplashScreen"] = "freecadsplash"；
        App::Application::Config()["CopyrightInfo"] = "\xc2xa9 Juergen Riegel, Werner Mayer, Yorik van Havre 2001-2015n"；
        Gui::Application::initApplication()；
        Py_InitModule("FreeCADGui", FreeCADGui_methods)；
    }
    catch (const Base::Exception& e) { PyErr_Format(PyErr_Format)
        PyErr_Format(PyExc_ImportError, "%sn", e.what())；
    }
    catch (...) { PyErr_SetString
        PyErr_SetString(PyExc_ImportError, "Unknown runtime error occurred")；
    }
}
```

********************************************************
